Crashing when adding the MapLayer.

Seg fault is down in QgsLegendLayer::updateIcon(), according
to gdb.

Upgrading to Lyon, 2.12, and it runs just fine.

It does show the editor tool pointer.

Clicking prints "Add", "Add" and gives a python error - stale calls to time.time()

--

Depending on the file format, need to either target a directory or a single file,
and call the corresponding qt dialog.

On removing plugin, cancel the callbacks, otherwise we get duplicate dialogs.
 - hmm - even on a fresh load of the plugin and QGIS, get 3 responses to the 
   browse button.


Fixed by skipping the auto-binding.

--

Next: 
 - loading multiple grids worked briefly, showed the edits just fine, but then the 
   edited grid disappeared. ???
   fresh qgis, no plugin reloads.  load one grid, load second grid.  first grid
    displays briefly, but then stops.
   all is fine before zooming at all...
   it's zooming which screws it up.


   - kill the_layer global
   - make sure repaint_freezes/queued are instance local
   - still doesn't work.
   - the second layer receives two calls to extent() both when it is unchecked and
     rechecked.  first layer only gets a call to extent() when it's checked.
   - calls to draw on only the second layer.

   - odd that when it goes to remove the layers, only one of them is recognized as an
     umbra layer.  the other is a 'qgis._core.QgsPluginLayer' 

   - my_repaint appears to be called only on the last layer loaded.
   - so as soon as a new layer is added, the previous one seems to lose it's identity
     as an umbra_layer.
   - opening python console causes both layers to lose their identities.

   - any chance that having unique names would help this out?  or some other
     
   - this is either a QGIS bug, or common misuse.  The openlayers plugin has this same
     issue.  Openlayers issue 10930 says this has been fixed since version 1.3.4 of
     the plugin.  Submitted update to that issue.

     does this occur just with plugin layers of the same type?  
     with any plugin layer? can add an open streetmap layer, and it seems fine.
     can load two open streetmap layers, and the first will disappear, but the grid 
       is still fine.
     with any layer at all?
     what if the UmbraLayer class wasn't shared between layers?
       no help.

 - dealing with cells!
    * display cell centers
    * delete cell by right-click on cell center
    * add cell with clean click in middle of polygon (<7 sides)


--

Proof of concept of using memory layers to handle the display - so we get
the usual styling and manipulation of those layers?

Try it out just via GUI:

new project
create memory layer - points
>>> layer=iface.mapCanvas().currentLayer()

>>> geom = QgsGeometry.fromPoint(QgsPoint(111,222))
>>> caps = layer.dataProvider().capabilities()
>>> feat = QgsFeature()
>>> feat.setGeometry(geom)

that worked!

--

After a long period of development outside of a proper plugin, it's time
to roll that back into a plugin to get access to more GUI elements.

ODD, but okay:
 - on OSX, seems that Ctrl-click is being interpreted as a non-left button
   click. Ah - Command-click appears as control-click
 - for some reason, to get the logs to work, have to open the python console
   and then reload the plugin.


PROBLEM:
 - some funkiness with releasing some of the callbacks.  Need to think through
   the difference between removing the dockwidget, deleting a single layer, and
   deleting all of the layers.

 probably closing the dockwidget should do nothing.
 for that matter, should be able to delete the node layer and keep on editing.

 if it's possible to watch for deletion of the group?  but there is still some trickiness
   to multiple deletes at one time.

 Lay out the various destructor paths:
   Umbra::onClosePlugin -- currently Umbra::dockwidget_show(), when creating the dockwidgert,
     connects closingPlugin to Umbra::onClosePlugin.  That's probably a bad idea.
     the handler here disconnects the currentLayerChanged signal, but doesn't try to
     remove layers.

   Umbra::unload -- I think this is for reloading the plugin. it tears down menus,
     and tries to remove any layers that are still around.  probably this should take
     care of removing any other signal connections, too.
     


change UmbraLayer to manage an arbitrary set of actual layers.

For a managed layer, it needs...
 a log object
   - can copy or reference UmbraLayer.log
 the grid, which it may add fields to, and/or register some callbacks
   - i.e. factor out extend_grid()
   - factor out install_edge_quality, update_edge_quality
     edge_quality becomes a field managed by the edge layer
 have to come up with a way to decouple the different parts of
   modify_node.  currently, this pushes geometry changes to all of
   the layers.  ways to do this
    a. each layer listens for the on_modify_node signals
    b. UnstructuredGrid gets new signals, on_edge_geometry_changed
       on_cell_geometry_changed, which would come out of on_node_geometry
       changed.


edge quality might be a bit tricky - it relies on having proper cell
centers, which are currently calculated by the cell layer.  fixing
this in UnstructuredGrid might be the best approach.

simple display is now working, but..
 - closing the dock widget crashes all of qgis.
   need to get logging working to debug this.
 
 - logging fixed, but the crash seems not to happen on linux.


  last messages when removing dockwidget:
  
2016-08-20 10:34:41,775 - umbra - INFO - on layer changed
2016-08-20 10:34:41,775 - umbra - INFO - Checking for layers in <Umbra.umbra_layer.UmbraLayer object at 0x12dbd78d0>
2016-08-20 10:34:41,776 - umbra - INFO - Checking for layers in <Umbra.umbra_layer.UmbraLayer object at 0x12dbd78d0>
2016-08-20 10:34:45,499 - umbra - INFO - ** cleaning up dockwidget
 <self.dockwidget was set to None here>
2016-08-20 10:34:45,499 - umbra - INFO - disconnected

A: if we don't listen to closingDockWidget at all - does that avoid the crash?
   yes.
Maybe for now, best to just skip any of that closeEvent stuff.  The use case
there is not clear anymore, since closing the dock widget no longer closes
down umbra.



NEXT:
 - selecting the group is not enough to figure out active gridlayer.
   because selecting a group means that canvas.currentLayer returns None
   maybe we need to talk to the legend?
   Hmm - no clear path forward on this - for now, be sure it doesn't
   cause crash, but don't bend over backwards to handle it.
   
 - undo
    The Qt way is through PyQt4.QtGui.QUndoCommand
    Each layer has an undoStack().
    QGIS toggles the availability of undo based on which layer is selected.
    undoStack.push() does that.
    command objects have undo() and redo().
    
    http://www.informit.com/articles/article.aspx?p=1187104&seqNum=3

 Adding to the clayer undo stack is fine, redo() gets called, ustack.canUndo()
 now returns True, but the GUI Undo option does not get set.

 Is it necessary to use QGIS::QgsVectorLayerUndoCommand, instead of just QUndoCommand?

 hmm - there is vectorLayer.startEditing(), after which vectorLayer.editBuffer()
 will give us a VectorLayerEditBuffer()

also an endEditCommand() member function
 ah - issuing a startEditing() worked, after which the Undo menu was active, and
  clicking Undo did in fact call the previously setup undo action.

 for better or worse, entering edit mode also changes the rendering of the cells,
 adding vertex markers.

  (a) is there a way to automatically enter/exit editing?
       startEditing() works...
       commitChanges() works.
       
  For my purposes, it may be easiest to use a QUndoStack, but wire in my own
  undo handling.

 1. Have the umbra tool intercept 'z' for undo. DONE

    Basic undo for moving nodes is working.
    Signals appear to propagate for toggling cells - that's nice.
    minor hiccup on a toggle cell, but other times it worked just fine.

    add/remove edge with undo is working.

    toggle cell is slow, but aside from that it work with undo.
    
    how about z and Z ? okay.

    moving a node can be redone with 'Z'
    
    redo on add edge works
    redo on toggling a cell does not always work..

    possible bug in delete_node_cascade() - had a case where it failed with an error
     about cells still referring to the node. happened again, after some attempts
     to toggle, undo toggle, redo toggle on some cells.

      - check on toggle cell:
        - does it remove node references to cells properly?
        - does it call the callbacks appropriately?
      It wasn't properly restoring the 'deleted' field on undeleting cells.
      Also changed to updating the cell center index instead of rebuilding on every add or delete.
         => much faster now
         => undo/redo at least paints and unpaints the cells.
         still get the node deletion error.

          removing/unremoving two cells, then remove a node they share => the two cells
           remain drawn, but the node's other cells disappear.
          delete_node_cascade does go through the edges to get to the cells, so it's
          possible that it is failing because edge_to_cells is messed up

          Now I get "Edge has cell neighbors" during the delete_node_cascade.
          The process here:
            1. Load grid
            2. Toggle a couple cells away
            3. Undo to restore them
            4. Delete a common node
            5. Get this error
     
  undoStack.clear() will do that.


 - saving grids
 - understand feature selections - i.e. for deleting or moving swath of cells.
 - maybe a dockwidget option to show some grid stats?
 - option to change maxnodes?
 - are any of the optimization approaches ready?  From Ed's comments, sounds like
   Janet uses an incremental construction - each pass pushing all of the nodes a bit
   closer to something like 


  
     
   
 
 
